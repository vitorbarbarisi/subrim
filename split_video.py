#!/usr/bin/env python3
"""
Split Video Processor
Processa um v√≠deo MP4 para compatibilidade com Chromecast e prepara para split

Usage: python3 split_video.py <directory_name>
Example: python3 split_video.py onibus132

O script:
1. Procura um arquivo MP4 dentro de assets/<directory_name>/
2. Cria uma pasta _sub
3. Move uma c√≥pia do MP4 para a pasta _sub
4. Ajusta essa c√≥pia para compatibilidade Chromecast
5. Chama fun√ß√£o split_video (por enquanto vazia)
"""

import sys
import argparse
import shutil
import subprocess
import os
import re
from pathlib import Path
from typing import Dict, List, Tuple


def find_mp4_file(directory: Path) -> Path:
    """Find the first MP4 file in the directory."""
    mp4_files = list(directory.glob("*.mp4"))
    if not mp4_files:
        raise FileNotFoundError(f"Nenhum arquivo MP4 encontrado em {directory}")
    return mp4_files[0]


def convert_to_chromecast_format(input_video: Path, output_video: Path) -> bool:
    """
    Converte v√≠deo para formato compat√≠vel com Chromecast.

    Args:
        input_video: V√≠deo original
        output_video: V√≠deo convertido para Chromecast

    Returns:
        True se convers√£o bem-sucedida
    """
    print("üì± Convertendo para formato Chromecast...")
    print(f"   üìÅ Entrada: {input_video.name}")
    print(f"   üìÅ Sa√≠da: {output_video.name}")

    # Configura√ß√µes testadas e aprovadas para Chromecast
    cmd = [
        'ffmpeg',
        '-i', str(input_video),

        # Codec de v√≠deo: H.264 software (m√°xima compatibilidade)
        '-c:v', 'libx264',
        '-profile:v', 'high',
        '-level', '4.1',

        # Qualidade otimizada para streaming
        '-crf', '20',              # Alta qualidade
        '-preset', 'medium',       # Equil√≠brio qualidade/velocidade

        # Codec de √°udio: AAC (padr√£o Chromecast)
        '-c:a', 'aac',
        '-b:a', '128k',           # Bitrate √°udio adequado
        '-ar', '48000',           # Sample rate padr√£o

        # Configura√ß√µes de compatibilidade
        '-pix_fmt', 'yuv420p',    # Formato pixel compat√≠vel
        '-movflags', '+faststart', # Otimiza√ß√£o streaming

        # Resolu√ß√£o m√°xima suportada pelo Chromecast
        '-vf', 'scale=min(1920\\,iw):min(1080\\,ih):force_original_aspect_ratio=decrease',

        # Progresso e otimiza√ß√µes
        '-progress', 'pipe:1',
        '-nostats',
        '-y',                     # Sobrescrever arquivo se existir

        str(output_video)
    ]

    try:
        print("   üîÑ Processando...")

        process = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            universal_newlines=True
        )

        # Mostrar progresso b√°sico
        for line in process.stdout:
            if line.startswith('frame='):
                parts = line.strip().split()
                for part in parts:
                    if part.startswith('time='):
                        time_str = part.split('=')[1]
                        print(f"   ‚è±Ô∏è  Progresso: {time_str}", end='\r')

        return_code = process.wait()

        if return_code != 0:
            stderr_output = process.stderr.read()
            print(f"\n‚ùå Erro na convers√£o:")
            print(f"   {stderr_output}")
            return False

        print("‚úÖ V√≠deo convertido para Chromecast com sucesso!")

        # Mostrar informa√ß√µes de tamanho
        if output_video.exists():
            original_size = input_video.stat().st_size / (1024*1024)
            converted_size = output_video.stat().st_size / (1024*1024)
            reduction = ((original_size - converted_size) / original_size) * 100

            print(".1f")
            print(".1f")
            print(".1f")

        return True

    except Exception as e:
        print(f"‚ùå Erro na convers√£o: {e}")
        return False


def split_video(video_path: Path) -> None:
    """
    Divide o v√≠deo em chunks de aproximadamente 30 segundos baseados no arquivo base.txt.

    Args:
        video_path: Caminho para o v√≠deo processado e compat√≠vel com Chromecast
    """
    print("üé¨ Fun√ß√£o split_video chamada!")
    print(f"   üìÅ V√≠deo para split: {video_path}")

    # Verificar se o v√≠deo existe
    if not video_path.exists():
        print(f"   ‚ùå V√≠deo n√£o encontrado: {video_path}")
        return

    # Encontrar o arquivo base.txt correspondente no diret√≥rio de origem
    source_dir = Path("assets") / video_path.parent.name.replace("_sub", "")
    base_file = None

    # Procurar por arquivos *_base.txt
    for file_path in source_dir.glob("*_base.txt"):
        base_file = file_path
        break

    if not base_file:
        print(f"   ‚ùå Arquivo base.txt n√£o encontrado em {source_dir}")
        return

    print(f"   üìÑ Base file encontrado: {base_file.name}")

    # Ler o arquivo base.txt
    subtitles = parse_base_file(base_file)
    if not subtitles:
        print("   ‚ùå Nenhuma legenda encontrada no arquivo base")
        return

    # Obter dura√ß√£o do v√≠deo
    video_width, video_height, video_duration = get_video_info(video_path)
    if video_duration <= 0:
        print("   ‚ùå N√£o foi poss√≠vel obter dura√ß√£o do v√≠deo")
        return

    print(f"   ‚è±Ô∏è  Dura√ß√£o do v√≠deo: {video_duration:.1f}s")
    print(f"   üìä Total de legendas: {len(subtitles)}")

    # Criar chunks de aproximadamente 30 segundos
    chunks = create_video_chunks(subtitles, video_duration)
    if not chunks:
        print("   ‚ùå N√£o foi poss√≠vel criar chunks")
        return

    print(f"   üé¨ Criados {len(chunks)} chunks")

    # Processar cada chunk
    for i, chunk in enumerate(chunks, 1):
        print(f"\n   üîÑ Processando chunk {i:03d}/{len(chunks):03d}")
        print(f"   ‚è±Ô∏è  Tempo: {chunk['start_time']:.1f}s - {chunk['end_time']:.1f}s")

        # Criar arquivo de v√≠deo do chunk
        chunk_video_path = video_path.parent / f"{video_path.stem}_chunk_{i:03d}{video_path.suffix}"

        # Cortar v√≠deo usando FFmpeg
        if cut_video_chunk(video_path, chunk_video_path, chunk['start_time'], chunk['end_time']):
            print(f"   ‚úÖ Chunk de v√≠deo criado: {chunk_video_path.name}")

            # Criar arquivo base.txt para o chunk
            chunk_base_path = video_path.parent / f"{video_path.stem}_chunk_{i:03d}_base.txt"
            create_chunk_base_file(chunk_base_path, chunk['subtitles'], chunk['start_time'])
            print(f"   üìù Arquivo base criado: {chunk_base_path.name}")
        else:
            print(f"   ‚ùå Falha ao criar chunk de v√≠deo {i:03d}")

    print(f"\nüéâ Split conclu√≠do! {len(chunks)} chunks criados.")


def parse_base_file(base_file_path: Path) -> Dict[float, Tuple[str, str, str, str, float]]:
    """
    Parse the base.txt file and return a mapping of begin_time -> (chinese subtitle, translations, translations_json, portuguese, duration).

    Returns:
        Dict mapping begin_time (as float seconds) to tuple of (chinese_text, translations_text, translations_json, portuguese_text, duration)
    """
    subtitles = {}

    try:
        with open(base_file_path, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                if not line:
                    continue

                # Split by tabs
                parts = line.split('\t')
                if len(parts) < 6:  # Precisa ter pelo menos 6 colunas (formato novo)
                    continue

                # Extract begin timestamp (second column)
                begin_timestamp_str = parts[1].strip()

                # Extract seconds from begin timestamp (e.g., "186.645s" -> 186.645)
                begin_match = re.match(r'([\d.]+)s?', begin_timestamp_str)
                if not begin_match:
                    continue

                begin_seconds = float(begin_match.group(1))

                # Extract end timestamp
                end_timestamp_str = parts[2].strip()
                end_match = re.match(r'([\d.]+)s?', end_timestamp_str)
                if not end_match:
                    continue

                end_seconds = float(end_match.group(1))

                # Calculate duration
                duration = max(0.5, end_seconds - begin_seconds)

                # Extract Chinese subtitle
                chinese_text = parts[3].strip()

                # Extract translations
                translations_json = parts[4].strip() if len(parts) >= 5 else ""
                portuguese_text = parts[5].strip() if len(parts) >= 6 else ""

                # Parse translations list if it exists
                formatted_translations = ""
                if translations_json and translations_json != 'N/A':
                    try:
                        # Remove outer brackets and parse as list
                        import ast
                        translations_list = ast.literal_eval(translations_json)
                        if isinstance(translations_list, list):
                            # Join translations with line breaks
                            formatted_translations = '\n'.join(translations_list)
                        else:
                            formatted_translations = translations_json
                    except:
                        # If parsing fails, use raw text
                        formatted_translations = translations_json
                else:
                    translations_json = ""

                # Clean Portuguese text
                if portuguese_text == 'N/A':
                    portuguese_text = ""

                if chinese_text and chinese_text != 'N/A':
                    subtitles[begin_seconds] = (chinese_text, formatted_translations, translations_json, portuguese_text, duration)

    except Exception as e:
        print(f"Erro ao ler arquivo base {base_file_path}: {e}")

    return subtitles


def create_video_chunks(subtitles: Dict[float, Tuple[str, str, str, str, float]], video_duration: float) -> List[Dict]:
    """
    Cria chunks de v√≠deo que respeitam os limites das legendas (sem cortar legendas no meio).

    Args:
        subtitles: Dicion√°rio com legendas
        video_duration: Dura√ß√£o total do v√≠deo em segundos

    Returns:
        Lista de chunks, cada um contendo start_time, end_time e subtitles
    """
    chunks = []
    target_chunk_duration = 30.0  # Dura√ß√£o alvo de 30 segundos

    # Ordenar legendas por tempo
    sorted_times = sorted(subtitles.keys())

    if not sorted_times:
        return chunks

    current_start = 0.0

    while current_start < video_duration:
        # Encontrar o melhor ponto de corte para este chunk
        chunk_end = find_best_chunk_end(current_start, target_chunk_duration, video_duration, subtitles, sorted_times)

        # Adicionar todas as legendas que t√™m alguma parte dentro deste chunk
        chunk_subs = {}
        for sub_time in sorted_times:
            _, _, _, _, duration = subtitles[sub_time]
            sub_end_time = sub_time + duration

            # Incluir legenda se:
            # 1. Come√ßa dentro do chunk (atual)
            # 2. OU termina dentro do chunk (mesmo que comece antes)
            if (current_start <= sub_time < chunk_end) or (current_start < sub_end_time <= chunk_end):
                chunk_subs[sub_time] = subtitles[sub_time]

        # Criar o chunk
        chunks.append({
            'start_time': current_start,
            'end_time': chunk_end,
            'subtitles': chunk_subs
        })

        # Pr√≥ximo chunk come√ßa com margem de seguran√ßa para evitar sobreposi√ß√£o
        # Adicionar offset maior para garantir que n√£o haja frames duplicados
        current_start = chunk_end + 0.05  # 50ms ap√≥s o fim para margem de seguran√ßa

        # Se chegamos ao fim do v√≠deo, parar
        if current_start >= video_duration:
            break

    return chunks


def find_best_chunk_end(current_start: float, target_duration: float, video_duration: float,
                        subtitles: Dict[float, Tuple[str, str, str, str, float]],
                        sorted_times: List[float]) -> float:
    """
    Encontra o melhor ponto de fim para um chunk, evitando cortar legendas no meio
    e garantindo que n√£o haja sobreposi√ß√£o de frames.

    Args:
        current_start: In√≠cio do chunk atual
        target_duration: Dura√ß√£o alvo do chunk
        video_duration: Dura√ß√£o total do v√≠deo
        subtitles: Dicion√°rio com todas as legendas
        sorted_times: Lista ordenada dos tempos de in√≠cio das legendas

    Returns:
        Melhor tempo de fim para o chunk
    """
    target_end = current_start + target_duration

    # Se o target_end j√° √© o fim do v√≠deo, usar ele
    if target_end >= video_duration:
        return video_duration

    # Procurar a √∫ltima legenda que termina antes ou no target_end
    best_end = target_end

    for sub_time in sorted_times:
        if sub_time >= current_start and sub_time < target_end:
            _, _, _, _, duration = subtitles[sub_time]
            sub_end_time = sub_time + duration

            # Se a legenda termina dentro do nosso target, considerar usar esse ponto
            if sub_end_time <= target_end:
                best_end = max(best_end, sub_end_time)
            # Se a legenda termina depois do target, mas come√ßa antes, precisamos
            # incluir ela inteira no chunk
            elif sub_time < target_end and sub_end_time > target_end:
                best_end = max(best_end, sub_end_time)

    # Garantir que n√£o ultrapassamos o limite m√°ximo (target_end + uma toler√¢ncia)
    max_end = min(target_end + 10.0, video_duration)  # M√°ximo 10s de toler√¢ncia

    # Se encontramos um bom ponto de corte, usar ele
    if best_end <= max_end:
        return best_end
    else:
        # Se n√£o encontramos um bom ponto, usar o target_end
        return target_end


def cut_video_chunk(input_video: Path, output_video: Path, start_time: float, end_time: float) -> bool:
    """
    Corta um chunk do v√≠deo usando FFmpeg com m√©todo otimizado para evitar quadros pretos.

    Args:
        input_video: V√≠deo de entrada
        output_video: V√≠deo de sa√≠da
        start_time: Tempo inicial em segundos
        end_time: Tempo final em segundos

    Returns:
        True se bem-sucedido
    """
    duration = end_time - start_time

    # M√©todo 1: Re-encoding preciso para evitar qualquer sobreposi√ß√£o (mais confi√°vel)
    cmd_precise = [
        'ffmpeg',
        '-i', str(input_video),
        '-ss', str(start_time),  # Start time exato
        '-t', str(duration),     # Duration exata
        '-c:v', 'libx264',      # Re-encode video para precis√£o
        '-c:a', 'aac',          # Re-encode audio para sincroniza√ß√£o
        '-preset', 'ultrafast',  # Encoding r√°pido
        '-crf', '20',           # Alta qualidade (ligeiramente reduzida para velocidade)
        '-keyint_min', '25',    # Keyframe m√≠nimo
        '-g', '25',             # GOP size fixo para consist√™ncia
        '-sc_threshold', '0',   # Desabilitar detec√ß√£o de cena para consist√™ncia
        '-avoid_negative_ts', 'make_zero',
        '-fflags', '+discardcorrupt+genpts',  # Gerar timestamps corretos
        '-y',
        str(output_video)
    ]

    # M√©todo 2: Usar -ss antes do input com verifica√ß√µes extras (fallback)
    safe_start_time = max(0, start_time - 0.01)  # 10ms antes para margem de seguran√ßa

    cmd_fast = [
        'ffmpeg',
        '-ss', str(safe_start_time),  # Start time BEFORE input com margem
        '-i', str(input_video),
        '-t', str(duration + 0.02),  # Duration + margem de 20ms
        '-c', 'copy',           # Copy streams
        '-avoid_negative_ts', 'make_zero',
        '-fflags', '+discardcorrupt+genpts',
        '-y',
        str(output_video)
    ]

    try:
        print(f"   üé¨ Cortando v√≠deo: {start_time:.1f}s - {end_time:.1f}s (dura√ß√£o: {duration:.1f}s)")

        # Primeiro tenta o m√©todo preciso (re-encoding) - mais confi√°vel
        print(f"   üîÑ Usando m√©todo preciso (re-encoding) para evitar sobreposi√ß√µes...")
        result = subprocess.run(cmd_precise, capture_output=True, text=True, check=False)

        if result.returncode == 0:
            print(f"   ‚úÖ M√©todo preciso bem-sucedido - sem sobreposi√ß√µes")
            return True
        else:
            print(f"   ‚ö†Ô∏è  M√©todo preciso falhou, tentando m√©todo r√°pido (copy)...")
            print(f"   ‚ö° Fallback para m√©todo r√°pido...")

            # Se o m√©todo preciso falhar, tenta o m√©todo r√°pido como fallback
            result = subprocess.run(cmd_fast, capture_output=True, text=True, check=False)

            if result.returncode == 0:
                print(f"   ‚úÖ M√©todo r√°pido bem-sucedido (fallback)")
                return True
            else:
                print(f"   ‚ùå Ambos os m√©todos falharam")
                print(f"   üìÑ Erro m√©todo preciso: {result.stderr[:200]}...")
                return False

    except Exception as e:
        print(f"   ‚ùå Erro ao cortar v√≠deo: {e}")
        return False


def create_chunk_base_file(base_file_path: Path, chunk_subtitles: Dict[float, Tuple[str, str, str, str, float]], chunk_start_time: float) -> None:
    """
    Cria arquivo base.txt para um chunk espec√≠fico com tempos ajustados.

    Args:
        base_file_path: Caminho para o arquivo base.txt de sa√≠da
        chunk_subtitles: Legendas do chunk
        chunk_start_time: Tempo inicial do chunk (para ajustar tempos)
    """
    try:
        with open(base_file_path, 'w', encoding='utf-8') as f:
            # Ordenar legendas por tempo
            sorted_times = sorted(chunk_subtitles.keys())

            for i, original_begin_time in enumerate(sorted_times, 1):
                chinese_text, formatted_translations, translations_json, portuguese_text, duration = chunk_subtitles[original_begin_time]

                # Ajustar tempos subtraindo o tempo inicial do chunk
                adjusted_begin_time = original_begin_time - chunk_start_time
                adjusted_end_time = adjusted_begin_time + duration

                # Formatar linha no mesmo formato do arquivo original
                line = f"{i}\t{adjusted_begin_time:.3f}s\t{adjusted_end_time:.3f}s\t{chinese_text}\t{translations_json}\t{portuguese_text}\n"
                f.write(line)

        print(f"   üìù Criado arquivo base com {len(chunk_subtitles)} legendas")

    except Exception as e:
        print(f"   ‚ùå Erro ao criar arquivo base: {e}")


def get_video_info(video_path: Path) -> Tuple[int, int, float]:
    """Get video dimensions and duration using ffprobe."""
    try:
        cmd = [
            'ffprobe',
            '-v', 'quiet',
            '-print_format', 'csv=p=0',
            '-select_streams', 'v:0',
            '-show_entries', 'stream=width,height,duration',
            str(video_path)
        ]

        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        parts = result.stdout.strip().split(',')
        width = int(parts[0])
        height = int(parts[1])
        duration = float(parts[2]) if parts[2] and parts[2] != 'N/A' else 0.0
        return width, height, duration
    except:
        # Default values if detection fails
        return 1920, 1080, 0.0


def check_ffmpeg() -> bool:
    """Check if FFmpeg is available."""
    try:
        subprocess.run(['ffmpeg', '-version'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL, check=True)
        return True
    except (subprocess.CalledProcessError, FileNotFoundError):
        return False


def cleanup_temp_files(dest_dir: Path, final_output: Path) -> None:
    """
    Remove arquivos tempor√°rios, mantendo apenas o arquivo final.
    """
    if not dest_dir.exists():
        return

    print("\nüßπ Limpando arquivos tempor√°rios...")

    # Lista de arquivos a manter (arquivo final + arquivos que n√£o s√£o tempor√°rios)
    keep_patterns = [
        final_output.name,  # Arquivo final
        "_chromecast.mp4",  # Arquivos j√° convertidos
    ]

    # Lista de arquivos a remover (tempor√°rios)
    remove_patterns = [
        "_chromecast_temp.mp4",  # Arquivos tempor√°rios de convers√£o
        ".fdash-video_por=",     # Fragmentos DASH
    ]

    cleaned_count = 0

    for file_path in dest_dir.glob("*.mp4"):
        should_remove = False

        # Verificar se deve ser removido baseado nos padr√µes
        for pattern in remove_patterns:
            if pattern in file_path.name:
                should_remove = True
                break

        # Se n√£o est√° nos padr√µes de remo√ß√£o, verificar se est√° nos de manuten√ß√£o
        if not should_remove:
            is_keep_file = False
            for pattern in keep_patterns:
                if pattern in file_path.name:
                    is_keep_file = True
                    break

            # Se n√£o √© arquivo de manuten√ß√£o e n√£o √© o arquivo final, remover
            if not is_keep_file and file_path != final_output:
                should_remove = True

        if should_remove:
            try:
                file_path.unlink()
                print(f"   üóëÔ∏è  Removido: {file_path.name}")
                cleaned_count += 1
            except OSError as e:
                print(f"   ‚ö†Ô∏è  N√£o foi poss√≠vel remover {file_path.name}: {e}")

    if cleaned_count > 0:
        print(f"‚úÖ {cleaned_count} arquivo(s) tempor√°rio(s) removido(s)")
    else:
        print("‚úÖ Nenhum arquivo tempor√°rio encontrado")


def main():
    parser = argparse.ArgumentParser(
        description="Processa v√≠deo MP4 para Chromecast e prepara para split (idempotente)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Exemplos:
  python3 split_video.py onibus132    # Processa v√≠deo em assets/onibus132/

Funcionamento (idempotente):
  1. Procura arquivo MP4 em assets/<directory_name>/
  2. S√≥ cria pasta _sub se n√£o existir
  3. S√≥ copia v√≠deo MP4 se n√£o existir na pasta _sub
  4. S√≥ converte para Chromecast se arquivo convertido n√£o existir
  5. Remove arquivos tempor√°rios ao final
  6. Chama fun√ß√£o split_video

Caracter√≠sticas:
  - Idempotente: executar m√∫ltiplas vezes √© seguro
  - N√£o sobrescreve arquivos existentes
  - Mant√©m apenas o arquivo final processado

Requisitos:
  - FFmpeg deve estar instalado
  - macOS: brew install ffmpeg
  - Ubuntu: sudo apt install ffmpeg
        """
    )

    parser.add_argument('directory', help='Nome do diret√≥rio dentro de assets/ para processar')

    args = parser.parse_args()

    # Construct assets directory path
    assets_dir = Path('assets')
    source_dir = assets_dir / args.directory
    dest_dir = assets_dir / f"{args.directory}_sub"

    if not assets_dir.exists():
        print(f"‚ùå Erro: Diret√≥rio assets n√£o encontrado em {assets_dir}")
        return 1

    if not source_dir.exists():
        print(f"‚ùå Erro: Diret√≥rio {source_dir} n√£o encontrado")
        return 1

    print("üé¨ Split Video Processor (Idempotente)")
    print("=" * 50)
    print(f"üìÅ Diret√≥rio origem: {source_dir}")
    print(f"üìÅ Diret√≥rio destino: {dest_dir}")

    # Check FFmpeg availability
    if not check_ffmpeg():
        print("‚ùå Erro: FFmpeg n√£o encontrado!")
        print("   Instale FFmpeg:")
        print("   macOS: brew install ffmpeg")
        print("   Ubuntu: sudo apt install ffmpeg")
        return 1

    try:
        # Step 1: Find MP4 file
        print("\nüîç Procurando arquivo MP4...")
        mp4_file = find_mp4_file(source_dir)
        print(f"‚úÖ MP4 encontrado: {mp4_file.name}")

        # Step 2: Create destination directory (only if doesn't exist)
        if dest_dir.exists():
            print(f"\nüìÅ Diret√≥rio {dest_dir.name} j√° existe - pulando cria√ß√£o")
        else:
            print(f"\nüìÅ Criando diret√≥rio {dest_dir.name}...")
            dest_dir.mkdir(parents=True, exist_ok=True)
            print("‚úÖ Diret√≥rio criado")

        # Step 3: Copy MP4 to destination directory (only if doesn't exist)
        dest_mp4 = dest_dir / mp4_file.name
        chromecast_output = dest_dir / f"{mp4_file.stem}_chromecast{mp4_file.suffix}"

        if chromecast_output.exists():
            print(f"\nüì± Arquivo Chromecast j√° existe: {chromecast_output.name}")
            print("‚è≠Ô∏è  Pulando processamento - v√≠deo j√° est√° pronto!")

            # Call split_video function even if file already exists
            print("\nüé¨ Chamando fun√ß√£o split_video...")
            split_video(chromecast_output)

            print("\n‚úÖ Processamento conclu√≠do (arquivo j√° existia)!")
            print(f"üìÅ Arquivo final: {chromecast_output.name}")
            return 0

        if dest_mp4.exists():
            print(f"\nüìã C√≥pia do v√≠deo j√° existe: {dest_mp4.name}")
            print("‚è≠Ô∏è  Pulando c√≥pia")
        else:
            print("\nüìã Copiando v√≠deo...")
            shutil.copy2(mp4_file, dest_mp4)
            print("‚úÖ V√≠deo copiado")

        # Step 4: Convert to Chromecast format (only if doesn't exist)
        print("\nüì± Convertendo para Chromecast...")
        if convert_to_chromecast_format(dest_mp4, chromecast_output):
            print("‚úÖ V√≠deo compat√≠vel com Chromecast criado")

            # Remove the original copy (keep only the Chromecast version)
            if dest_mp4.exists():
                dest_mp4.unlink()
                print("üóëÔ∏è  C√≥pia original removida")

            # Step 5: Clean up temporary files
            cleanup_temp_files(dest_dir, chromecast_output)

            # Step 6: Call split_video function
            print("\nüé¨ Chamando fun√ß√£o split_video...")
            split_video(chromecast_output)

            print("\n‚úÖ Processamento conclu√≠do!")
            print(f"üìÅ Arquivo final: {chromecast_output.name}")
            return 0
        else:
            print("‚ùå Erro na convers√£o para Chromecast")
            return 1

    except FileNotFoundError as e:
        print(f"‚ùå Erro: {e}")
        return 1
    except Exception as e:
        print(f"‚ùå Erro inesperado: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
